### **1. 状态机模式（State Machine）**

**场景**：处理有限状态转换（如按键检测、通信协议解析）。  
**优势**：逻辑清晰，避免复杂的条件分支。  
**示例**：按键状态检测（空闲、按下、消抖、释放）。


```
typedef enum {
    STATE_IDLE,
    STATE_PRESSED,
    STATE_DEBOUNCE,
    STATE_RELEASED
} ButtonState;

ButtonState button_state = STATE_IDLE;

void button_handler() {
    switch (button_state) {
        case STATE_IDLE:
            if (read_button()) {
                button_state = STATE_PRESSED;
                start_timer(20); // 20ms消抖
            }
            break;
        case STATE_PRESSED:
            case STATE_DEBOUNCE:
                if (timer_expired()) {
                    if (read_button()) {
                        button_state = STATE_RELEASED;
                        on_button_click(); // 触发回调
                    } else {
                        button_state = STATE_IDLE;
                    }
                }
                break;
        // ...其他状态处理
    }
}
```

---

### **2. 分层架构（Layered Architecture）**

**场景**：硬件与软件解耦（如驱动层、中间件层、应用层）。  
**优势**：降低模块耦合性，便于移植和维护。  
**结构**：

- **硬件抽象层（HAL）**：封装GPIO、SPI、UART等硬件操作。
    
- **中间件层**：提供协议栈（如MQTT）、文件系统。
    
- **应用层**：业务逻辑。
    

```

// HAL层示例：GPIO抽象
typedef struct {
    void (*init)(void);
    void (*set)(uint8_t value);
} GPIO_Driver;

// 应用层通过接口操作硬件
GPIO_Driver led_driver = {
    .init = led_init,
    .set = led_set
};

led_driver.init();
led_driver.set(1);
```

---

### **3. 事件驱动模式（Event-Driven）**

**场景**：传感器数据采集、GUI交互。  
**优势**：避免轮询，节省CPU资源。  
**实现**：使用队列管理事件，主循环处理事件。


```
typedef enum {
    EVENT_SENSOR_UPDATE,
    EVENT_BUTTON_PRESS
} EventType;

typedef struct {
    EventType type;
    void* data;
} Event;

Queue event_queue;

void main_loop() {
    while (1) {
        if (!queue_empty(&event_queue)) {
            Event e = queue_pop(&event_queue);
            switch (e.type) {
                case EVENT_SENSOR_UPDATE:
                    handle_sensor(e.data);
                    break;
                // ...其他事件处理
            }
        }
        enter_low_power_mode(); // 空闲时进入低功耗
    }
}
```

---

### **4. 观察者模式（Observer）**

**场景**：传感器数据更新时通知多个模块（如温度采集后触发显示和存储）。  
**实现**：注册回调函数列表。



```
typedef void (*TemperatureCallback)(float temp);

TemperatureCallback callbacks[MAX_OBSERVERS];
int num_callbacks = 0;

void register_temperature_callback(TemperatureCallback cb) {
    callbacks[num_callbacks++] = cb;
}

void temperature_update(float temp) {
    for (int i = 0; i < num_callbacks; i++) {
        callbacks[i](temp); // 通知所有观察者
    }
}

```
---

### **5. 静态分配模式（Static Allocation）**

**场景**：资源受限系统，避免动态内存分配。  
**实现**：预先分配固定大小的内存池或对象池。



```
#define MAX_TASKS 10
Task task_pool[MAX_TASKS]; // 静态任务池
Task* task_create() {
    for (int i = 0; i < MAX_TASKS; i++) {
        if (!task_pool[i].used) {
            task_pool[i].used = 1;
            return &task_pool[i];
        }
    }
    return NULL; // 池已满
}
```

---

### **6. 中断处理模式（ISR + Bottom Half）**

**场景**：高实时性要求的外设响应（如UART接收）。  
**原则**：中断服务例程（ISR）尽量短，复杂逻辑交给主循环。


```
volatile uint8_t rx_buffer[128];
volatile uint8_t rx_index = 0;

// ISR仅做数据拷贝
void UART_RX_ISR() {
    rx_buffer[rx_index++] = UART_DR;
    if (rx_index >= 128) rx_index = 0;
}

// 主循环处理数据
void process_uart_data() {
    if (rx_index > 0) {
        parse_data(rx_buffer, rx_index);
        rx_index = 0;
    }
}
```

---

### **7. 模板方法模式（Template Method）**

**场景**：算法框架固定，细节可变（如不同通信协议的帧处理）。  
**实现**：通过函数指针实现“虚函数”。



```
typedef struct {
    void (*send)(const uint8_t* data, size_t len);
    void (*receive)(uint8_t* buffer, size_t len);
} ProtocolDriver;

void send_packet(ProtocolDriver* driver, const uint8_t* data) {
    driver->send(data, calculate_crc(data)); // 公共逻辑：添加CRC
}
```

---

### **8. 发布-订阅模式（Pub-Sub）**

**场景**：模块间松耦合通信（如传感器数据广播）。  
**实现**：使用消息队列或全局事件总线。



```
// 全局事件总线
void publish(Event* event);
void subscribe(EventType type, Callback cb);

```
---

### **设计模式选择原则**

1. **实时性**：中断处理优先选择短平快的设计。
    
2. **资源占用**：静态分配优于动态分配。
    
3. **可维护性**：分层和模块化降低复杂度。
    
4. **可移植性**：硬件抽象层隔离平台差异。
    

通过合理应用这些模式，可以显著提升嵌入式代码的可靠性、可维护性和可扩展性。